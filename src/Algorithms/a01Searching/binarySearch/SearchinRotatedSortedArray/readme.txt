在旋转排序数组中搜索
想象一个原本升序的数组，比如 [0, 1, 2, 4, 5, 6, 7]。现在，将它从某个点“旋转”一下，就可能得到 [4, 5, 6, 7, 0, 1, 2]。这就是旋转排序数组。

核心挑战：直接取中间值 mid，我们无法确定 target 是在左边还是右边。例如，在 [4, 5, 6, 7, 0, 1, 2] 中，mid 是 7。目标值 5 在左边，而目标值 1 也在左边（但跨过了旋转点）。

突破口：旋转后的数组有一个非常关键的特性：当我们取 mid 将数组分成两半时，其中一半必然是局部有序的。

我们的任务就是在每一步找出这个有序的子数组，然后判断 target 是否在这个有序区间内。

解题逻辑
判断nums[i]与nums[m]的关系
如果i<m说明,左边是有序的,然后再看target是否在里面,否则前往另一侧
如果i>m说明右边是有序的(因为左右必有一个区间是有序的)同上
i=m的话,情况比较特殊,要放到i<m的分支里,因为这种情况发生在只有一或二个元素,只能证明左边是有序的,右边无法证明,比如[3,1]
左边[3]是有序的,右边[3,1]不是有序的(注意要包含m)


/问:判断哪边有序后又要判断target在哪里,但最后还是前往target,那不是有点多此一举了吗
//答:因为我不知道target在哪里,只能找到有序区间才能判断target是否在里面,如果不在就是在另一个区间